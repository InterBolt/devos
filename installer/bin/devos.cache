#!/usr/bin/env bash

# shellcheck source=devos.static
source "devos.static"

LIB_CACHE_READY=false

cache._validate() {
  if [ "$LIB_CACHE_READY" == "false" ]; then
    log.error "flags.ready has not been called."
    exit 1
  fi
  if [ -z "$vENV_NAME" ]; then
    log.error "vENV_NAME must be non empty. Exiting."
    exit 1
  fi
}
cache.ready() {
  LIB_CACHE_READY=true
  log.debug "devos.cache - ready"
}
cache.del() {
  if [ "$LIB_CACHE_READY" == "false" ]; then
    log.error "cache.ready must be called first. Exiting."
    exit 1
  fi
  cache._validate
  local tmp_filepath="$vSTATIC_SELF_ROOT/.cache-$vENV_NAME-$1"
  rm -f "$tmp_filepath"
}
cache.clear() {
  if [ "$LIB_CACHE_READY" == "false" ]; then
    log.error "cache.ready must be called first. Exiting."
    exit 1
  fi
  cache._validate
  for file in "$vSTATIC_SELF_ROOT"/.cache-"$vENV_NAME"*; do
    rm -f "$file"
  done
}
#
# Important: this follows the same pattern as how we curl api endpoints.
# We store the response in a global variable and then use the global var on subsequent lines.
# While this feels like a shitty way to do this, it's actually quite nice AS LONG AS
# there's only one way to "get" things in a particular category of functions.
#
cache.get() {
  if [ "$LIB_CACHE_READY" == "false" ]; then
    log.error "cache.ready must be called first. Exiting."
    exit 1
  fi
  cache._validate
  local tmp_filepath="$vSTATIC_SELF_ROOT/.cache-$vENV_NAME-$1"
  if [ -f "$tmp_filepath" ]; then
    cat "$tmp_filepath"
  else
    echo ""
  fi
}
cache.set() {
  if [ "$LIB_CACHE_READY" == "false" ]; then
    log.error "cache.ready must be called first. Exiting."
    exit 1
  fi
  cache._validate
  local tmp_filepath="$vSTATIC_SELF_ROOT/.cache-$vENV_NAME-$1"
  if [ ! -f "$tmp_filepath" ]; then
    touch "$tmp_filepath"
  fi
  echo "$2" >"$tmp_filepath"
}
cache.prompt() {
  if [ "$LIB_CACHE_READY" == "false" ]; then
    log.error "cache.ready must be called first. Exiting."
    exit 1
  fi
  cache._validate
  local input
  input="$(cache.get "$1")"
  if [ -z "$input" ]; then
    echo "Enter the $1:"
    read -r input
    if [ -z "$input" ]; then
      log.error "the $1 cannot be empty. Exiting."
      exit 1
    fi
    cache.set "$1" "$input"
  fi
  cache.get "$1"
}
cache.overwrite_on_empty() {
  if [ "$LIB_CACHE_READY" == "false" ]; then
    log.error "cache.ready must be called first. Exiting."
    exit 1
  fi
  cache._validate
  local cached_val
  cached_val="$(cache.get "$1")"
  local next_val="$2"
  if [ -z "$cached_val" ]; then
    cache.set "$1" "$next_val"
  fi
  cache.get "$1"
}
