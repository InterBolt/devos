#!/usr/bin/env bash

LIB_FLAGS_HEADER_AVAILABLE_COMMANDS="Available commands:"
LIB_FLAGS_HEADER_AVAILABLE_OPTIONS="Available options:"

# shellcheck source=devos
source "devos.static"
# shellcheck source=devos.utils
source "devos.static"
# shellcheck source=devos.static
source "devos.static"
#
# Print top level usage information
#
flags.help() {
  cat <<EOF
Usage: devos command [--OPTS...]

The DevOS installer CLI to manage DevOS installations on your local computer or dev container.

$LIB_FLAGS_HEADER_AVAILABLE_COMMANDS

help                     - Print this help and exit
launch                   - Launch the devos installation. Will repair an installation if it exists.
checkout                 - Checkout a devos directory to avoid having to provide the directory
                           on every command.
status                   - Print the status of the devos installation.
sync-bin                 - Sync the local devos bin executable at /usr/local/bin/devos to the docker 
                           container.
sync-config              - Sync the .devos config folder to the remote server.
sync-env                 - Sync the .env and .env.sh files in your devos directory to the remote server.
backup                   - Archive the devos installation, caprover backup, and postgres backup
                           to the s3 bucket.
restore                  - Restore the devos installation, caprover backup, and postgres backup
                           from the s3 bucket.
code                     - Open the vscode workspaces associated with the installation.
test                     - Runs tests on the devos installation.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--help                   - Print this help and exit

Source: https://github.com/InterBolt/devos
EOF
}
#
# Print launch command usage information
#
flags.cmd.launch.help() {
  cat <<EOF
Usage: devos launch [--OPTS...]

Launch a new installation, complete a partial installation, or repair an existing installation.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
--hard-reset        - Dangerously recreate installation files and infrastructure.
--clear-cache       - Clear the cache and ignore previously stored values.
EOF
}
#
# Print sync-config command usage information
#
flags.cmd.sync_config.help() {
  cat <<EOF
Usage: devos sync-config [--OPTS...]

Sync the .devos config folder to the remote server.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
EOF
}
#
# Print sync-config command usage information
#
flags.cmd.status.help() {
  cat <<EOF
Usage: devos status [--OPTS...]

Print the status of the devos installation.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
EOF
}
#
# Print sync-env command usage information
#
flags.cmd.sync_env.help() {
  cat <<EOF
Usage: devos sync-config [--OPTS...]

Sync the .env and .env.sh files to the remote server.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
EOF
}
#
# Print launch command usage information
#
flags.cmd.test.help() {
  cat <<EOF
Usage: devos test [--OPTS...]

Run tests on the installation to ensure it's working as expected.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
EOF
}
#
# Print checkout command usage information
#
flags.cmd.checkout.help() {
  cat <<EOF
Usage: devos checkout [--OPTS...]

Launch a new installation, complete a partial installation, or repair an existing installation.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
EOF
}
#
# Print launch command usage information
#
flags.cmd.code.help() {
  cat <<EOF
Usage: devos code [--OPTS...]

Open the vscode workspaces associated with the installation.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
EOF
}
#
# Print backup command usage information
#
flags.cmd.backup.help() {
  cat <<EOF
Usage: devos backup [--OPTS...]

Backup the installation, caprover, and postgres to the s3 bucket.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
--tag=<string>      - The tag to use for the backup.
--allow-local       - Allow the .devos folder we backup to come from the 
                      local machine. This is useful for restoring a backup
                      to a new machine. By default, it will always try to backup
                      the .devos folder from the container since that's our primary
                      workspace.
EOF
}
#
# Print restore command usage information
#
flags.cmd.restore.help() {
  cat <<EOF
Usage: devos restore [--OPTS...]

Restore the installation, caprover, and postgres from the s3 bucket.

$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS

--dir               - The directory of your devos project. (required on the first run)
--help              - Print this help and exit
--tag=<string>      - When supplied, we'll restore the latest backup that 
                      matches the tag. If no tag is supplied, we'll restore
                      the latest backup.
EOF
}
flags._is_valid_help_command() {
  if [ "$1" = "--help" ] || [ "$1" = "-h" ] || [ "$1" = "help" ]; then
    echo "true"
  else
    echo "false"
  fi
}
flags.parse_cmd() {
  if [ -z "$1" ]; then
    log.error "No command supplied."
    flags.help
    exit 0
  fi
  if [ "$(flags._is_valid_help_command "$1")" == "true" ]; then
    flags.help
    exit 0
  fi
  while [ "$#" -gt 0 ]; do
    if [ "$(flags._is_valid_help_command "$1")" == "true" ]; then
      if [ -z "$vCLI_PARSED_CMD" ]; then
        log.error "invalid command, use \`devos --help\` to see available commands."
        exit 1
      fi
      flags."$vCLI_PARSED_CMD".help
      exit 0
    fi
    case "$1" in
    --*)
      local key=$(echo "$1" | awk -F '=' '{print $1}' | sed 's/^--//')
      local value=$(echo "$1" | awk -F '=' '{print $2}')
      vCLI_PARSED_OPTIONS+=("$key=$value")
      ;;
    *)
      if [ -z "$1" ]; then
        break
      fi
      local cmd_name=$(echo "$1" | tr '-' '_')
      local is_allowed=false
      for allowed_cmd_name in "${vCLI_USAGE_ALLOWS_CMDS[@]}"; do
        if [ "$cmd_name" == "$allowed_cmd_name" ]; then
          is_allowed=true
        fi
      done
      if [ "$is_allowed" == "false" ]; then
        log.error "Unknown command: $1"
      else
        vCLI_PARSED_CMD="$cmd_name"
      fi
      ;;
    esac
    shift
  done
}

flags.parse_requirements() {
  for cmd_name in $(flags.help | grep -A 1000 "$LIB_FLAGS_HEADER_AVAILABLE_COMMANDS" | grep -B 1000 "$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS" | grep -v "$LIB_FLAGS_HEADER_AVAILABLE_COMMANDS" | grep -v "$LIB_FLAGS_HEADER_AVAILABLE_OPTIONS" | grep -E "^[a-z]" | awk '{print $1}'); do
    cmd_name=$(echo "$cmd_name" | tr '-' '_')
    if [ "$cmd_name" != "help" ]; then
      vCLI_USAGE_ALLOWS_CMDS+=("$cmd_name")
    fi
  done
  for cmd in "${vCLI_USAGE_ALLOWS_CMDS[@]}"; do
    opts="$cmd("
    first=true
    for cmd_option in $(flags.cmd."$cmd".help | grep -E "^--" | awk '{print $1}'); do
      cmd_option=$(echo "$cmd_option" | awk -F '=' '{print $1}' | sed 's/^--//')
      if [ "$first" = true ]; then
        opts="$opts$cmd_option"
      else
        opts="$opts,$cmd_option"
      fi
      first=false
    done
    vCLI_USAGE_ALLOWS_OPTIONS+=("$opts)")
  done
}
flags.validate_options() {
  if [ -n "${vCLI_PARSED_OPTIONS[0]}" ]; then
    for parsed_cmd_option in "${vCLI_PARSED_OPTIONS[@]}"; do
      for allowed_cmd_option in "${vCLI_USAGE_ALLOWS_OPTIONS[@]}"; do
        cmd_name=$(echo "$allowed_cmd_option" | awk -F '(' '{print $1}')
        cmd_options=$(echo "$allowed_cmd_option" | awk -F '(' '{print $2}' | awk -F ')' '{print $1}')
        if [ "$cmd_name" == "$vCLI_PARSED_CMD" ]; then
          is_cmd_option_allowed=false
          flag_name=$(echo "${parsed_cmd_option}" | awk -F '=' '{print $1}')
          for cmd_option in $(echo "$cmd_options" | tr ',' '\n'); do
            if [ "$cmd_option" == "$flag_name" ]; then
              is_cmd_option_allowed=true
            fi
          done
          if [ "$is_cmd_option_allowed" == false ]; then
            echo ""
            echo "Command option: ${parsed_cmd_option} is not allowed for command: $vCLI_PARSED_CMD."
            echo ""
            exit 1
          fi
        fi
      done
    done
  fi
}
