#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail
set -o errtrace
#
# TODO: still don't know why I ever put these bashrc source
# TODO[c]: commands in here. Leaving until I can confirm
# TODO[c]: that they're not needed.
#
rm -rf /root/.bashrc
touch /root/.bashrc
. /root/.bashrc
cd "$(dirname "${BASH_SOURCE[0]}")"
#
# Important: please prefix with "v" to avoid collisions with
# the environment variables that are sourced from the .env file.
#
vCONFIG_DIR="/root/config"
vBIN_SCRIPT_FILEPATH="$vCONFIG_DIR/bin/solos"
vUSR_BIN_FILEPATH="/usr/local/bin/solos"
vGITHUB_REPO="InterBolt/solos"
vCLONE_DIR=/root/solos
vDOCKER_ENV_PATH="/root/project/.env"
vREMOTE_ENV_PATH="/root/.env"
vENV_PATH=""
vSERVER_DIR=""
vARG_HOST="$1"
vARG_SERVER="$2"
#
# Add a check since we can't get this directory from the solos.static
# script. vCONFIG_DIR should be the .solos folder that we uploaded or mounted
# to the server from our local machine.
#
if [ ! -d "$vCONFIG_DIR" ]; then
  echo "$vCONFIG_DIR does not exist. this must exist in all non-local environments." >&2
  exit 1
fi
if [ -z "$vARG_HOST" ]; then
  echo "No argument provided. Expected <host> <server>" >&2
  exit 1
fi
if [ "$vARG_HOST" != "docker" ] && [ "$vARG_HOST" != "remote" ]; then
  echo "<host> argument must be either 'docker' or 'remote'." >&2
  exit 1
fi
if [ "$vARG_HOST" == "docker" ]; then
  vENV_PATH="$vDOCKER_ENV_PATH"
  if [ ! -f "$vBIN_SCRIPT_FILEPATH" ]; then
    echo "$vBIN_SCRIPT_FILEPATH should exist after we mounted the local config folder to the dev docker container. Nothing found." >&2
    exit 1
  fi
else
  vENV_PATH="$vREMOTE_ENV_PATH"
fi
if [ ! -f "$vENV_PATH" ]; then
  echo "$vENV_PATH does not exist." >&2
  exit 1
fi
#
# Load the env variables and confirm that the things we
# need are set.
#
# shellcheck disable=SC2046
export $(grep -v '^#' "$vENV_PATH" | xargs)
if [ -z "$GITHUB_TOKEN" ] || [ -z "$GITHUB_EMAIL" ] || [ -z "$GITHUB_EMAIL" ]; then
  echo "GITHUB_TOKEN, GITHUB_EMAIL, and GITHUB_EMAIL must be set in $vENV_PATH" >&2
  exit 1
fi
#
# Install Git
#
mkdir -p -m 755 /etc/apt/keyrings
wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | tee /etc/apt/keyrings/githubcli-archive-keyring.gpg >/dev/null
chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list >/dev/null
apt update
#
# Setup the github account and repo
#
apt install gh -y
mkdir -p /root/.tmp
echo "$GITHUB_TOKEN" >/root/.tmp/github_token
gh auth login --git-protocol https --hostname github.com --with-token </root/.tmp/github_token
rm -f /root/.tmp/github_token
git config --global user.email "$GITHUB_EMAIL"
git config --global user.name "$GITHUB_EMAIL"
#
# Clone the SolOS repo from github.
# TODO: should I pull the latest changes if it exists?
# TODO[c]: I lean towards no to avoid anything unexpected.
#
if [ ! -d "$vCLONE_DIR" ]; then
  gh repo clone "$vGITHUB_REPO" "$vCLONE_DIR"
fi
cd "$vCLONE_DIR"
#
# Now check that the server type we want to install exists.
# Note: this check shouldn't really ever fail since we're
# checking it on the local machine before we kick this script
# off. HOWEVER, since we're not pulling the latest repo changes
# by default, there's a chance that the server type we want to
# install doesn't exist in the repo.
#
vSERVER_DIR="servers/$vARG_SERVER"
if [ ! -d "$vSERVER_DIR" ]; then
  echo "$vCLONE_DIR/$vSERVER_DIR does not exist!" >&2
  echo "The repo on this server must be out of sync with the local repo. Exiting." >&2
  exit 1
fi
# Make the things executable
find . -type f -name "*.sh" -exec chmod +x {} \;
find bin -type f -name "solos*" -exec chmod +x {} \;
chmod +x install
#
# Run the remaining commands from within the boot folder
#
cd "$vSERVER_DIR"/.boot
#
# Run the start script associated with the host
#
# shellcheck disable=SC1090
. "$vARG_HOST".sh
#
# When invoking the `solos` cli, the remote will tell you not to
# and the docker container will invoke the script that is living in the
# mounted config directory. This is the `.solos` directory on your local
# machine.
#
# Important: Don't change to use the mounted repo's bin script.
# I'd rather they be in sync and out of date than out of sync
# and up to date. If we want to invoke the bin script in the repo
# we should, just like, do that manually.
#
if [ -f "$vUSR_BIN_FILEPATH" ]; then
  rm -f "$vUSR_BIN_FILEPATH"
fi
if [ "$vARG_HOST" == "docker" ]; then
  {
    echo "#!/usr/bin/env bash"
    echo ""
    echo "# This script was generated by the solos installer at $(date)."
    echo ""
    echo "$vBIN_SCRIPT_FILEPATH \"\$@\""
  } >>"$vUSR_BIN_FILEPATH"
  chmod +x "$vBIN_SCRIPT_FILEPATH"
  chmod +x "$vUSR_BIN_FILEPATH"
else
  {
    echo "#!/usr/bin/env bash"
    echo ""
    echo "# This script was generated by the solos installer at $(date)."
    echo ""
    echo "echo \"This script is not meant to be run on a remote server.\" >&2"
  } >>"$vUSR_BIN_FILEPATH"
  chmod +x "$vUSR_BIN_FILEPATH"
fi
