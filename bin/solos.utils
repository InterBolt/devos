#!/usr/bin/env bash

# shellcheck source=solos
. "solos.static"
# shellcheck source=solos.utils
. "solos.static"
# shellcheck source=solos.static
. "solos.static"

utils.echo_line() {
  terminal_width=$(tput cols)
  line=$(printf "%${terminal_width}s" | tr " " "-")
  echo "$line"
}
utils.debug_dump_vars() {
  utils.echo_line
  compgen -A variable -X '!v[A-Z_]*' | sort | while read -r line; do
    echo "$line=${!line}"
  done
  utils.echo_line
}
utils.exit_trap() {
  local code=$?
  if [ $code -eq 1 ]; then
    # utils.debug_dump_vars
    exit 1
  fi
  exit $code
}
#
# This function is used to inject global variables into template files.
# It will search for all instances of __[_A-Z]*__ in the file and replace them with the
# corresponding global variable. If the global variable is not set, it will exit with an error.
# If the behavior is set to "commit", it will replace the variables in the file.
# If the behavior is set to "dry", it will only check if the variables are set.
#
utils.template_variables() {
  local dir_or_file="$1"
  local behavior="$2"
  local empty_behavior="{$3:-fail_on_empty}"
  local eligible_files=()
  if [ -z "$behavior" ]; then
    log.error "utils.template_variables: behavior cannot be empty"
    exit 1
  fi
  if [ "$behavior" != "dry" ] && [ "$behavior" != "commit" ]; then
    log.error "utils.template_variables: \$2 must equal either \"dry\" or \"commit\""
    exit 1
  fi
  #
  # Note: don't fail on an empty directory, because we expect that to happen.
  # due the recursive nature of this function.
  #
  if [ -d "$dir_or_file" ]; then
    for file in "$dir_or_file"/*; do
      if [ -d "$file" ]; then
        utils.template_variables "$file" "$2"
      fi
      if [ -f "$file" ]; then
        eligible_files+=("$file")
      fi
    done
  elif [ -f "$dir_or_file" ]; then
    eligible_files+=("$dir_or_file")
  fi
  #
  # Terminating condition for the recursive function.
  #
  if [ "${#eligible_files[@]}" -eq 0 ]; then
    return
  fi
  local errored=false
  for file in "${eligible_files[@]}"; do
    grepped=$(grep -o "__v[_A-Z]*__" "$file" || echo "")
    for line in $grepped; do
      local var_names="${line//____/__  __}"
      for var_name in ${var_names}; do
        var_name=${var_name//__/}
        if [ -z "${var_name// /}" ]; then
          continue
        fi
        if [ -z ${!var_name+x} ]; then
          echo "var_name: $var_name"
          log.error "$file is using an undefined variable: $var_name"
          errored=true
          continue
        fi
        if [ "$empty_behavior" == "fail_on_empty" ] && [ -z "${!var_name}" ]; then
          log.error "$file is using an empty variable: $var_name"
          errored=true
          continue
        fi
        if [ "$errored" == false ]; then
          log.debug "found $var_name in $file"
        fi
        if [ "$errored" == "false" ] && [ "$behavior" == "commit" ]; then
          sed -i '' "s,\_\_$var_name\_\_,${!var_name},g" "$file"
        fi
      done
    done
  done
  if [ "$errored" == "true" ]; then
    exit 1
  fi
}
utils.date() {
  date +"%Y-%m-%d %H:%M:%S"
}
utils.grep_global_vars() {
  grep -o -w '^$*v[A-Z_]\+' "$1" | grep -v "#" || echo ""
}
utils.files_match_dir() {
  local dir_to_match="$1"
  if [ ! -d "$dir_to_match" ]; then
    log.error "directory does not exist: $dir_to_match"
    exit 1
  fi
  local files_to_match=("${@:2}")
  for file_to_match in "${files_to_match[@]}"; do
    if [ ! -f "$dir_to_match/$file_to_match" ]; then
      log.error "bootfile does not exist: $dir_to_match/$file_to_match"
      exit 1
    fi
  done
  for dir_file in "$dir_to_match"/*; do
    if [ ! -f "$dir_file" ]; then
      continue
    fi
    dir_filename="$(basename "$dir_file")"
    found=false
    for file_to_match in "${files_to_match[@]}"; do
      if [ "$file_to_match" == "$dir_filename" ]; then
        found=true
      fi
    done
    if [ "$found" == false ]; then
      log.error "(${files_to_match[*]}) does not contain: $dir_filename"
      exit 1
    fi
  done
}
