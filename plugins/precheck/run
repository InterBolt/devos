#!/usr/bin/env bash

# What is this script?
# ---------------------
# This script will run before any installed plugins are executed in order to validate some set of assumptions around
# files, networking, and other such things. If this script fails, SolOS will enter a "panicked" state and will not
# execute any further plugins. This script should be as simple as possible and should not rely on any external dependencies.
# Note: installed plugins cannot be shell scripts, they should be statically linked binaries. This precheck plugin script is the
# exception.

# SolOS Plugin API:
# -----------------
# The plugin API is fundamentally based on some set of files and folders that get included in the firejailed sandbox where a plugin executable runs.
# A plugin executable should implement various phases by conditionally executing code based on the value of the first argument supplied to it.
# Each phase gets read/write access to specific files and folders and the SolOS daemon is responsible for ensuring these files and folders
# are created, destroyed, and shared with subsequent phases. And
#
# Rules for each --[phase] are as follows:
# ----------------------------------------
# --phase-configure
#   - available filesystem [file:/root/config.json (read/write)]
#       - file:/root/config.json is a file that may or may not exist. If it does that means the user
#         has configured the plugin in some other step. A plugin should validate the config file if it
#         exists and if it doesn't, it should create a default one.
#   - networking [none]
# --phase-download
#   - available filesystem [file:/root/config.json (read only), dir:/root/download (read/write)]
#       - file:/root/config.json is a file that may or may not exist. If it does that means the user
#         has configured the plugin in some other step. A plugin should validate the config file if it
#         exists and if it doesn't, it should create a default one.
#       - dir:/root/download is an empty directory where the plugin will store any downloaded files.
#   - networking [allowed]
# --phase-collection
#   - available filesystem [file:/root/config.json (read only), dir:/root/collection (read/write), dir:/root/.solos (read only)]
#       - dir:/root/.solos contains all of the users config, projects, app, everything
#         related to SolOS and their development environment.
#       - dir:/root/collection is an empty directory where the plugin will store "collected" data that
#         it downloads/extracts from the internet and the user's .solos directory.
#   - networking [none]
# --phase-process
#   - available filesystem [file:/root/config.json (read only), dir:/root/collection (read only), dir:/root/.solos (read only), file:/root/processed.json (read/write)]
#       - dir:/root/collection files from the collection phase.
#       - dir:/root/.solos same as above.
#       - file:/root/processed.json stores the "processed" data that the plugin generates. Since plugin authors will write their plugins using "real"
#         programming languages, JSON seems like a good format for the processed data. The SolOS daemon combines json from all plugins into a single
#         JSON array where objects are in the format: { "plugin": "plugin-name", "data": { ... } }.
#   - networking [none]
# --phase-push
#   - available filesystem [file:/root/config.json (read only), file:/root/processed.json (read only)]
#       - file:/root/processed.log is a file where each line is the encoded json from the processed.json files produced by all the plugins.
#   - networking [allowed]
#
# Threat model - negligence/accidental leaks:
# -------------------------------------------
# If SolOS is a usable service for the general public, it's probably DOA if it must fend of highly sophisticated and malicious plugin authors.
# So instead of worrying too much about that, the focus should instead be on making it difficult for a reasonably trustworthy authors to accidentally
# damage or leake sensitive user data.
# There could come a time where SolOS develops the sophistication to ward off even the worse actors, but even then, the nature of using the
# processed data from a plugin to inform an LLM response bot could result in a malicious actor using a plugin to generate a subtle, probabilistic response that
# convinces the user to do something harmful. This is a problem that can't be solved through a purely technical solution. Ultimately, software
# like this will long term depend on the existence of a community of users who can help each other and the developers to identify and remove
# harmful plugins.
#
# Security via plugin phases:
# ---------------------------
# 1. The collection phase can only download things when accessing the users projects, configs, apps, etc. So if our scrubbing of those files
#    is insufficient and an API key is exposed, the plugin can't accidentally upload it to the internet.
# 2. The process phase can only read the data collected in the collection phase but cannot access the internet at all.
# 3. The push phase can do uploads, but it can only access a single file of processed log lines, which is far less likely to contain
#    leaked information. Furthermore, we can do an additional scrubbing pass in between the process and push phases to catching any leaks in
#    that processed file.

run__phase=""
if [[ ${1} == "--phase-configure" ]]; then
  run__phase="configure"
elif [[ ${1} == "--phase-download" ]]; then
  run__phase="download"
elif [[ ${1} == "--phase-collection" ]]; then
  run__phase="collection"
elif [[ ${1} == "--phase-process" ]]; then
  run__phase="process"
elif [[ ${1} == "--phase-push" ]]; then
  run__phase="push"
fi
if [[ -z ${run__phase} ]]; then
  echo "${0} must equal one of --phase-configure, --phase-download, --phase-collection, --phase-process, or --phase-push."
  exit 1
fi

verify.absence() {
  for path in "${@}"; do
    if [[ -e ${path} ]]; then
      echo "SOLOS_KILL: ${path} should not exist."
      exit 1
    fi
  done
}
verify.read_write() {
  for path in "${@}"; do
    if [[ ! -w ${path} ]]; then
      echo "SOLOS_KILL: ${path} should be set to read/write."
      exit 1
    fi
  done
}
verify.read_only() {
  for path in "${@}"; do
    if [[ -w ${path} ]]; then
      echo "SOLOS_KILL: ${path} should be set to read only."
      exit 1
    fi
  done
}
verify.files_exists() {
  for path in "${@}"; do
    if [[ ! -f ${path} ]]; then
      echo "SOLOS_KILL: ${path} file should exist."
      exit 1
    fi
  done
}
verify.dirs_exists() {
  for path in "${@}"; do
    if [[ ! -d ${path} ]]; then
      echo "SOLOS_KILL: ${path} directory should exist."
      exit 1
    fi
  done
}
verify.network_acccess_enabled() {
  local urls=(
    "https://www.google.com"
    "https://www.github.com"
    "https://www.example.com"
    "https://www.facebook.com"
    "https://www.twitter.com"
    "https://www.linkedin.com"
    "https://www.instagram.com"
    "https://www.reddit.com"
    "https://www.youtube.com"
    "https://www.netflix.com"
    "https://www.hulu.com"
  )
  for url in "${urls[@]}"; do
    if curl -s -I ${url} >/dev/null; then
      return 0
    else
      echo "Attempt to access ${url} failed." >&2
    fi
  done
  exit 1
}
verify.network_acccess_disabled() {
  local urls=(
    "https://www.google.com"
    "https://www.github.com"
    "https://www.example.com"
    "https://www.facebook.com"
    "https://www.twitter.com"
    "https://www.linkedin.com"
    "https://www.instagram.com"
    "https://www.reddit.com"
    "https://www.youtube.com"
    "https://www.netflix.com"
    "https://www.hulu.com"
  )
  for url in "${urls[@]}"; do
    if curl -s -I ${url} >/dev/null; then
      echo "SOLOS_KILL: Network access should be disabled."
      exit 1
    fi
  done
  return 0
}
phase.configure() {
  verify.absence \
    "/root/.solos" \
    "/root/download" \
    "/root/collection" \
    "/root/processed.json"
  local config_file="/root/config.json"

  verify.files_exists "${config_file}"
  verify.network_acccess_disabled
}
phase.download() {
  verify.absence \
    "/root/.solos" \
    "/root/collection" \
    "/root/processed.json"
  local config_file="/root/config.json"
  local download_dir="/root/download"

  verify.dirs_exists "${download_dir}"
  verify.files_exists "${config_file}"
  verify.read_write "${download_dir}"
  verify.read_only "${config_file}"
  verify.network_acccess_enabled
}
phase.collection() {
  verify.absence \
    "/root/download" \
    "/root/processed.json"
  local config_file="/root/config.json"
  local solos_dir="/root/.solos"
  local collection_dir="/root/collection"

  verify.files_exists "${config_file}"
  verify.dirs_exists "${solos_dir}"
  verify.read_only "${solos_dir}" "${config_file}"
  verify.read_write "${collection_dir}"
  verify.network_acccess_disabled
}
phase.process() {
  verify.absence \
    "/root/download"
  local solos_dir="/root/.solos"
  local collection_dir="/root/collection"
  local processed_file="/root/processed.json"

  verify.dirs_exists "${solos_dir}" "${collection_dir}"
  verify.files_exists "${processed_file}"
  verify.read_only "${solos_dir}" "${collection_dir}"
  verify.read_write "${processed_file}"
  verify.network_acccess_disabled
}
phase.push() {
  verify.absence \
    "/root/download" \
    "/root/collection" \
    "/root/.solos"
  local processed_file="/root/processed.json"

  verify.files_exists "${processed_file}"
  verify.read_only "${processed_file}"
  verify.network_acccess_enabled
}

phase."${run__phase}"
